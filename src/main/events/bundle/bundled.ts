// This file is auto-generated by dtscommands.
// Do not edit this file manually.
import { Event } from 'dtscommands'
import client from '../../../index.js'
import { ChannelType, Colors, EmbedBuilder, Guild, TextChannel, GuildMember, ActivityType, ButtonInteraction, StringSelectMenuInteraction } from 'discord.js'
import moment from 'moment'
import vouchClient from '../../../vouchClient.js'
import { ON_JOIN_CHANNEL_ID, ON_LEAVE_CHANNEL_ID } from '../../../config.js'
import { BotEmbed } from '../../../utils/Embeds.js'
import chalk from 'chalk'
import { ShinexRoles } from '../../../utils/Validations.js'
import { OnApprove, OnAskProof, OnDeny, VouchControl } from '../../../utils/vouch.js'

// Content From D:\DISCORD TS\shinex\src\main\events/Client/ready.ts

import * as Role from '../../../cache/role.js'

// Content From D:\DISCORD TS\shinex\src\main\events/Client/onJoin.ts

export class OnJoinEvent extends Event<'guildCreate'> {
  constructor () {
    super({
      name: 'guildCreate',
      nick: 'OnJoin'
    })
  }

  async run (guild: Guild) {
    const channel = client.channels.cache.get(ON_JOIN_CHANNEL_ID) as TextChannel
    const own = await guild?.fetchOwner()
    const text = guild.channels.cache.find(
      c =>
        c.type === ChannelType.GuildText &&
        c.permissionsFor(client.user?.id || '0000')?.has('CreateInstantInvite')
    ) as TextChannel
    let invite = { code: 'xxxxxx' }
    if (text) {
      invite = await text.createInvite({
        reason: `For ${client.user?.tag} Developer(s)`,
        maxAge: 0
      })
    }
    const embed = new EmbedBuilder()
      .setThumbnail(guild.iconURL({ size: 1024 }))
      .setTitle('üì• Joined a Guild !!')
      .setColor(Colors.Green)
      .addFields([
        { name: 'Name', value: `\`${guild.name}\`` },
        { name: 'ID', value: `\`${guild.id}\`` },
        {
          name: 'Owner',
          value: `\`${own.user.username || 'Unknown user'}\` ${own.id}`
        },
        { name: 'Member Count', value: `\`${guild.memberCount}\` Members` },
        {
          name: 'Creation Date',
          value: `\`${moment.utc(guild.createdAt).format('DD/MMM/YYYY')}\``
        },
        {
          name: 'Guild Invite',
          value: `[Here is ${guild.name} invite ](https://discord.gg/${invite.code})`
        },
        {
          name: `${client.user?.username}'s Server Count`,
          value: `\`${client.guilds.cache.size}\` Servers`
        }
      ])
      .setTimestamp()

    try {
      channel.send({ embeds: [embed] })
    } catch (e) {}

    const members = await guild.members.fetch()
    members.forEach(async member => {
      await vouchClient.profiles.register({
        id: member.id,
        username: member.user.username
      })
    })
  }
}

// Content From D:\DISCORD TS\shinex\src\main\events/Client/onLeave.ts

export class OnLeaveEvent extends Event<'guildDelete'> {
  constructor () {
    super({
      name: 'guildDelete',
      nick: 'OnLeave'
    })
  }

  async run (guild: Guild) {
    const channel = client.channels.cache.get(
      ON_LEAVE_CHANNEL_ID
    ) as TextChannel
    const own = await guild?.fetchOwner()

    const embed = new BotEmbed()
      .setThumbnail(guild.iconURL({ forceStatic: false, size: 1024 }))
      .setTitle('üì§ Left a Guild !!')
      .setColor(Colors.DarkRed)
      .addFields([
        { name: 'Name', value: `\`${guild.name}\`` },
        { name: 'ID', value: `\`${guild.id}\`` },
        {
          name: 'Owner',
          value: `\`${own.user.username || 'Unknown user'}\` ${own.id}`
        },
        { name: 'Member Count', value: `\`${guild.memberCount}\` Members` },
        {
          name: 'Creation Date',
          value: `\`${moment.utc(guild.createdAt).format('DD/MMM/YYYY')}\``
        },
        {
          name: `${client.user?.username}'s Server Count`,
          value: `\`${client.guilds.cache.size}\` Servers`
        }
      ])
      .setTimestamp()
    channel?.send({ embeds: [embed] })
  }
}

// Content From D:\DISCORD TS\shinex\src\main\events/Client/onMember.ts

export class NewMember extends Event<'guildMemberAdd'> {
  constructor () {
    super({
      name: 'guildMemberAdd',
      nick: 'New Member'
    })
  }

  async run (member: GuildMember) {
    const guild = member.guild
    if (guild.id !== '1157258354821971998') return

    const profile = await vouchClient.profiles.fetch({
      username: member.user.username,
      id: member.id
    })

    if (!profile) return

    await profile.addBadge('MEMBER')
  }
}

export class ReadyEvent extends Event<'ready'> {
  constructor () {
    super({
      name: 'ready',
      once: true
    })
  }

  async run () {
    console.info(`Client logged in as "${client.user?.tag}"`, chalk.bold('cli'))
    client.user?.setPresence({
      activities: [
        {
          name: '„Ç∑„Éç„ÉÉ„ÇØ„Çπ | +help',
          type: ActivityType.Streaming
        }
      ],
      status: 'online'
    })

    const guild = client.guilds.cache.get('1157365694950809692')
    await guild?.members.fetch()

    const roleMap: Record<ShinexRoles, string> = {
      ShinexAdminValidation: '1157680973882871878',
      ShinexSeniorModValidation: '1166348577996541952',
      ShinexStaffValidation: '1157579034562150482'
    }

    const AdminRole = await guild?.roles.fetch(roleMap.ShinexAdminValidation)
    const SeniorModRole = await guild?.roles.fetch(
      roleMap.ShinexSeniorModValidation
    )
    const StaffRole = await guild?.roles.fetch(roleMap.ShinexStaffValidation)

    AdminRole?.members.forEach(member => {
      Role.ShinexAdmins.add(member.id)
    })

    SeniorModRole?.members.forEach(member => {
      Role.ShinexSeniorMods.add(member.id)
    })

    StaffRole?.members.forEach(member => {
      Role.ShinexStaffs.add(member.id)
    })
  }
}

// Content From D:\DISCORD TS\shinex\src\main\events/vouch/handler.ts
/* eslint-disable @typescript-eslint/ban-ts-comment */

export class VouchManager extends Event<'interactionCreate'> {
  constructor () {
    super({
      name: 'interactionCreate',
      nick: 'VouchManager'
    })
  }

  async run (interaction: ButtonInteraction | StringSelectMenuInteraction) {
    if (!interaction.isButton() && !interaction.isStringSelectMenu()) return

    if (!interaction.customId.startsWith('vouch:')) return

    await interaction.deferUpdate()

    const vouch =
      vouchClient.vouches.cache.get(interaction.customId.split(':')[1]) ||
      (await vouchClient.vouches.fetch(interaction.customId.split(':')[1]))

    if (!vouch) return

    // if (
    //   (vouch.receiverId === interaction.user.id ||
    //     vouch.voucherId === interaction.user.id) &&
    //   !process.env.DEV
    // ) {
    //   return interaction.followUp({
    //     content: 'You can not control vouches related to you!',
    //     ephemeral: true
    //   })
    // }

    // disable the buttons in the message
    await interaction.message.edit({
      components: [
        // @ts-expect-error
        VouchControl(vouch, {
          disableAccept: interaction.customId.split(':')[2] === 'accept',
          disableDeny: interaction.customId.split(':')[2] === 'deny',
          disableProofReceiver:
            interaction.customId.split(':')[2] === 'proofreceiver',
          disableProofVoucher:
            interaction.customId.split(':')[2] === 'proofvoucher'
        }),
        ...interaction.message.components.filter(c => c.components.length === 1)
      ]
    })

    switch (interaction.customId.split(':')[2]) {
      case 'accept':
        await OnApprove(vouch, interaction.user, interaction.message)
        break
      case 'deny':
        await OnDeny(
          vouch,
          interaction.user,
          interaction.message,
          interaction instanceof StringSelectMenuInteraction &&
            interaction.values[0]
            ? interaction.values[0]
            : undefined
        )
        break
      case 'proofreceiver':
        await OnAskProof(
          vouch,
          interaction.user,
          'RECEIVER',
          interaction.message
        )
        break
      case 'proofvoucher':
        await OnAskProof(
          vouch,
          interaction.user,
          'VOUCHER',
          interaction.message
        )
        break
    }
  }
}
