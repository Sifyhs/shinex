// This file is auto-generated by dtscommands.
// Do not edit this file manually.
import { GuildMember, ActivityType, ButtonInteraction, StringSelectMenuInteraction } from 'discord.js'
import { Event } from 'dtscommands'
import { UpdateProfile } from '../../../cache/profile.js'
import client from '../../../index.js'
import chalk from 'chalk'
import { VouchStaffs } from '../../../cache/role.js'
import prisma from '../../../prisma.js'
import { OnApprove, OnAskProof, OnDeny, VouchControl } from '../../../utils/vouch.js'

// Content From D:\Devloper project\DISCORD TS\shinex\src\main\events/Client/onMember.ts

export class NewMember extends Event<'guildMemberAdd'> {
  constructor () {
    super({
      name: 'guildMemberAdd',
      nick: 'New Member'
    })
  }

  async run (member: GuildMember) {
    const guild = member.guild
    if (guild.id !== '1157258354821971998') return

    await member.roles.add('1157693300074086423')

    await UpdateProfile(member.id, {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      badges: {
        push: 'MEMBER'
      }
    }).catch(console.error)
  }
}

// Content From D:\Devloper project\DISCORD TS\shinex\src\main\events/Client/ready.ts

export class ReadyEvent extends Event<'ready'> {
  constructor () {
    super({
      name: 'ready',
      once: true
    })
  }

  async run () {
    console.info(`Client logged in as "${client.user?.tag}"`, chalk.bold('cli'))
    client.user?.setPresence({
      activities: [
        {
          name: 'シネックス | +help',
          type: ActivityType.Streaming
        }
      ],
      status: 'online'
    })

    const guild = client.guilds.cache.get('1157365694950809692')
    await guild?.members.fetch()
    const vouchStuffRole = guild?.roles.cache.get('1157579034562150482')

    vouchStuffRole?.members.forEach(member => {
      VouchStaffs.add(member.id)
    })
  }
}

// Content From D:\Devloper project\DISCORD TS\shinex\src\main\events/vouch/handler.ts
/* eslint-disable @typescript-eslint/ban-ts-comment */

export class VouchManager extends Event<'interactionCreate'> {
  constructor () {
    super({
      name: 'interactionCreate',
      nick: 'VouchManager'
    })
  }

  async run (interaction: ButtonInteraction | StringSelectMenuInteraction) {
    if (!interaction.isButton() && !interaction.isStringSelectMenu()) return

    if (!interaction.customId.startsWith('vouch:')) return

    await interaction.deferUpdate()

    const vouch = await prisma.vouch.findUnique({
      where: {
        id: parseInt(interaction.customId.split(':')[1])
      }
    })

    if (!vouch) return

    // disable the buttons in the message
    await interaction.message.edit({
      components: [
        // @ts-expect-error
        VouchControl(vouch, {
          disableAccept: interaction.customId.split(':')[2] === 'accept',
          disableDeny: interaction.customId.split(':')[2] === 'deny',
          disableProofReceiver:
            interaction.customId.split(':')[2] === 'proofreceiver',
          disableProofVoucher:
            interaction.customId.split(':')[2] === 'proofvoucher'
        }),
        ...interaction.message.components.filter(c => c.components.length === 1)
      ]
    })

    if (
      (vouch.receiverId === interaction.user.id ||
        vouch.voucherId === interaction.user.id) &&
      !process.env.DEV
    ) {
      return interaction.followUp({
        content: 'You can not control vouches related to you!',
        ephemeral: true
      })
    }

    switch (interaction.customId.split(':')[2]) {
      case 'accept':
        await OnApprove(vouch, interaction.user, interaction.message)
        break
      case 'deny':
        await OnDeny(
          vouch,
          interaction.user,
          interaction.message,
          interaction instanceof StringSelectMenuInteraction &&
            interaction.values[0]
            ? interaction.values[0]
            : undefined
        )
        break
      case 'proofreceiver':
        await OnAskProof(
          vouch,
          interaction.user,
          'RECEIVER',
          interaction.message
        )
        break
      case 'proofvoucher':
        await OnAskProof(
          vouch,
          interaction.user,
          'VOUCHER',
          interaction.message
        )
        break
    }
  }
}
