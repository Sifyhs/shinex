// This file is auto-generated by dtscommands.
// Do not edit this file manually.
import { Command, CommandRun } from 'dtscommands'
import { BotEmbed, ProfileEmbed, VouchEmbed, VouchNotification } from '../../../utils/Embeds.js'
import { del60, del9, del25, ColorsFromImage, HexStringToInt, UserFromMessage, del30, ExtractIdsAndReason } from '../../../utils/fun.js'
import moment from 'moment'
import vouchClient from '../../../vouchClient.js'
import { Colors, GuildMember } from 'discord.js'
import { BadgeType, Badges } from '../../../utils/profile.js'
import { ShinexRoles, isAnyStaff } from '../../../utils/Validations.js'
import { VouchStatusSchema } from 'vouchapi'
import { VouchStatusMap, VouchStatusShortMap, OnApprove, OnDeny, DenyReasons } from '../../../utils/vouch.js'
import client from '../../../index.js'

// Content From D:\DISCORD TS\shinex\src\main\commands/Bot/help.ts

export class HelpCmd extends Command {
  constructor () {
    super({
      category: 'Bot',
      description: 'Get the list of commands',
      name: 'help',
      aliases: ['commands']
    })
  }

  async run ({ message, client, args }: CommandRun) {
    const embed = new BotEmbed()

    const commands = client.commands

    if (args[0] && commands.get(args[0].toLowerCase())) {
      const command = commands.get(args[0].toLowerCase()) as Command
      embed.setTitle(command.name + ' | Help')
      embed.setDescription(command.description)
      embed.addFields(
        {
          name: 'Usage',
          value:
            '`' +
            client.config.prefix +
            command.name +
            ' ' +
            command.usage +
            '`'
        },
        {
          name: 'Aliases',
          value: command.aliases?.join(', ') || 'None'
        }
      )
      embed.setColor(0x1b03a3)

      return message.channel
        .send({
          embeds: [embed]
        })
        .then(del60)
    }

    const categories: { [key: string]: Command[] } = {}

    commands.forEach(command => {
      if (command.category === 'Staff') return
      if (!categories[command.category]) {
        categories[command.category] = []
      }
      categories[command.category].push(command)
    })

    embed.setTitle('Commands')
    embed.setDescription(
      'Here is a list of all the commands you can use on the bot.'
    )
    embed.addFields(
      Object.keys(categories).map(category => {
        return {
          name: category,
          value: categories[category]
            .map(
              command =>
                `**${client.config.prefix}${command.name}** ${command.description}`
            )
            .join('\n')
        }
      })
    )
    embed.setColor(0x1b03a3)
    embed.setThumbnail(client.user?.displayAvatarURL() || '')

    await message.channel
      .send({
        embeds: [embed]
      })
      .then(del60)
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/Bot/invite.ts

export class InviteCmd extends Command {
  constructor () {
    super({
      name: 'invite',
      description: 'Invite the bot to your server',
      category: 'Bot'
    })
  }

  async run ({ message }: CommandRun) {
    const embed = new BotEmbed({
      title: 'Invite Me | ' + message.client.user.username,
      description: `[Shinex](https://discord.com/api/oauth2/authorize?client_id=${message.client.user.id}&permissions=412317149184&scope=bot%20applications.commands)\n[Shinex Support](https://discord.gg/9ZhRGmXcJK)`,
      color: 0x1b03a3
    })

    message.channel.send({
      embeds: [embed]
    })
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/Bot/stat.ts

export class BotStatusCmd extends Command {
  constructor () {
    super({
      name: 'stat',
      description: 'Get the status of the bot',
      category: 'bot'
    })
  }

  async run ({ message, args }: CommandRun) {
    const uptime = process.uptime()
    const formatted = moment
      .duration(uptime, 'seconds')
      .humanize()
      .replace('a few seconds', 'less than a minute')
      .replace(' minutes', 'm')
      .replace(' hours', 'h')
      .replace(' days', 'd')
      .replace(' weeks', 'w')
      .replace(' months', 'mo')
      .replace(' years', 'y')
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/leaderboard/hot.ts

export class LeaderBoardHot extends Command {
  constructor () {
    super({
      name: 'hot',
      description: 'Hot Users of the week',
      category: 'Leaderboard'
    })
  }

  async run ({ message }: CommandRun) {
    const embed = new BotEmbed({
      title: 'Hot Users of this week | Shinex Leaderboard',
      color: 0x00ff00
    })

    const messageToReply = await message.channel.send({
      embeds: [embed]
    })

    const top10 = await vouchClient.leaderboard.hot10()

    if (!top10?.length) {
      embed.setDescription('No users found.')
      return messageToReply.edit({
        embeds: [embed]
      })
    }

    const formatted = top10.map((user, index) => {
      return `${`  **${index + 1}**  `}| User: ${user.username.replace(
        /_/,
        '\\_'
      )} - **${user.weeklyVouches}** vouches`
    })

    embed.setDescription(formatted.join('\n'))

    messageToReply.edit({
      embeds: [embed]
    })
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/leaderboard/top.ts

const Top3Emojis = [
  '<:top1:1158322922298015794>',
  '<:top2:1158322918221152286>',
  '<:top3:1158322913036992634>'
]

export class TopCmd extends Command {
  constructor () {
    super({
      name: 'top',
      description: '',
      category: 'Leaderboard'
    })
  }

  async run ({ message }: CommandRun) {
    const embed = new BotEmbed({
      title: 'Top 10 Users | Shinex Leaderboard',
      color: 0x00ff00
    })

    const messageToReply = await message.channel.send({
      embeds: [embed]
    })

    const top10 = await vouchClient.leaderboard.top10()

    if (!top10?.length) {
      embed.setDescription('No users found.')
      return messageToReply.edit({
        embeds: [embed]
      })
    }

    const formatted = top10.map((user, index) => {
      return `${
        Top3Emojis[index] || `  **${index + 1}**  `
      }| User: ${user.username.replace(/_/, '\\_')} - **${
        user.importedVouches + user.positiveVouches
      }** vouches`
    })

    embed.setDescription(formatted.join('\n'))

    messageToReply.edit({
      embeds: [embed]
    })
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/profile/banner.ts

export class SetBannerCmd extends Command {
  constructor () {
    super({
      category: 'Profile',

      description: 'Set your banner',

      name: 'banner',
      args: true,
      usage: '<banner link>'
    })
  }

  async run ({ message, args }: CommandRun) {
    const banner = args.join(' ').trim()

    if (banner.length > 200) {
      return message.channel.send('Banner link is too long').then(del9)
    }

    const profile = await vouchClient.profiles.update(
      { id: message.author.id, username: message.author.username },
      {
        banner
      }
    )

    if (!profile) {
      return message.channel.send('Failed to update profile').then(del9)
    }

    const embed = new ProfileEmbed(profile, message.author)

    await message.channel
      .send({
        content: 'Your banner has been set',
        embeds: [embed]
      })
      .then(del9)
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/profile/forum.ts

export class SetForumCmd extends Command {
  constructor () {
    super({
      name: 'forum',
      category: 'Profile',
      description: 'Set your forum profile',
      args: true,
      usage: 'forum'
    })
  }

  async run ({ message, args }: CommandRun) {
    const forum = args.join(' ').trim()

    if (forum.length > 200) {
      return message.channel.send('Forum is too long').then(del9)
    }

    const profile = await vouchClient.profiles.update(
      { id: message.author.id, username: message.author.username },
      {
        forum
      }
    )

    if (!profile) {
      return message.channel.send('Failed to update profile').then(del9)
    }

    const embed = new ProfileEmbed(profile, message.author)

    await message.channel
      .send({
        content: 'Your forum has been set',
        embeds: [embed]
      })
      .then(del9)
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/profile/products.ts

export class SetProductsCmd extends Command {
  constructor () {
    super({
      name: 'products',
      description: 'Set your products',
      category: 'Profile',
      args: true,
      usage: '<products>'
    })
  }

  async run ({ message, args }: CommandRun) {
    const products = args.join(' ').trim()

    if (products.length > 200) {
      return message.channel.send('Products are too long').then(del9)
    }

    const profile = await vouchClient.profiles.update(
      { id: message.author.id, username: message.author.username },
      {
        products
      }
    )

    if (!profile) {
      return message.channel.send('Failed to update profile').then(del9)
    }

    const embed = new ProfileEmbed(profile, message.author)
    await message.channel
      .send({
        content: 'Your shop has been set',
        embeds: [embed]
      })
      .then(del25)
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/profile/profile.ts

export class ProfileCmd extends Command {
  constructor () {
    super({
      name: 'profile',
      description: 'Shows your profile',
      category: 'Profile',
      aliases: ['p'],
      usage: '[user]'
    })
  }

  async run ({ message, args }: CommandRun) {
    const userFetchStart = new Date().getTime()

    const user = await UserFromMessage(message, args, {
      authorAsDefault: true,
      authorFromMessageAsReply: true
    })
    if (!user) {
      return message.reply('unknown user').then(del9)
    }

    console.trace(userFetchStart, 'User fetch time took: ')

    if (user.bot) return

    const messageToReply = await message.channel.send({
      embeds: [
        new BotEmbed({
          title: `${user.username}'s Profile`,
          color: 0x1b03a3,
          thumbnail: {
            url: user.displayAvatarURL()
          },
          description: `**ID:** ${user.id}\n**Age:**<t:${Math.floor(
            user.createdAt.getTime() / 1000
          )}:D>\n**Display Name:** ${user.displayName}\n**Mention:** <@${
            user.id
          }>`
        })
      ]
    })

    const profileFetchStart = new Date().getTime()

    const profile =
      vouchClient.profiles.cache.get(user.id) ||
      (await vouchClient.profiles.fetch({
        id: user.id,
        username: user.username
      }))

    console.trace(profileFetchStart, 'Profile fetch time took: ')

    if (!profile) {
      return messageToReply.edit({
        embeds: [
          new BotEmbed({
            title: `${user.username}'s Profile`,
            thumbnail: {
              url: user.displayAvatarURL()
            },
            color: 0x1b03a3,
            description: 'Failed to load profile'
          })
        ]
      })
    }

    try {
      const embed = new ProfileEmbed(profile, user)

      await messageToReply
        .edit({
          embeds: [embed]
        })
        .then(msg => {
          if (message.author.id === user.id) {
            del60(msg)
          } else {
            del25(msg)
          }
        })

      if (!profile.color) {
        const colors = await ColorsFromImage(
          user.displayAvatarURL({
            forceStatic: true,
            extension: 'png'
          })
        )
        const color = HexStringToInt(colors[0])
        await messageToReply.edit({
          embeds: [embed.setColor(color)]
        })
      }
    } catch (error) {
      console.log(error)
    }
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/profile/search.ts

export class SearchProductCmd extends Command {
  constructor () {
    super({
      name: 'search',
      description: 'Search for a product',
      category: 'Profile',
      args: true,
      usage: '<product>'
    })
  }

  async run ({ message, args }: CommandRun) {
    const query = args.join(' ').trim()

    const products = await vouchClient.profiles.searchProduct(query)

    const embed = new BotEmbed()
    embed.setTitle('Search Results')

    if (!products?.length) {
      embed.setDescription('No products found')
      return message.channel.send({ embeds: [embed] }).then(del9)
    }

    const formatted = products
      .sort(
        (a, b) =>
          b.positiveVouches +
          b.importedVouches -
          a.positiveVouches -
          a.importedVouches
      )
      .map(product => {
        return `Seller: \`${product.username}\` - **${
          product.importedVouches + product.positiveVouches
        }** vouches,\n\`\`\`\n[${product.products}]\`\`\``
      })

    embed.setDescription(
      formatted.join('\n') +
        '\n\nIn Search of ' +
        query +
        ', we found some sellers'
    )

    message.reply({ embeds: [embed] }).then(del30)
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/profile/shop.ts

export class SetShopCmd extends Command {
  constructor () {
    super({
      name: 'shop',
      description: 'Set your shop',
      category: 'Profile'
    })
  }

  async run ({ message, args }: CommandRun) {
    const shop = args.join(' ').trim()

    if (shop.length > 200) {
      return message.channel.send('Shop is too long').then(del9)
    }

    const profile = await vouchClient.profiles.update(
      { id: message.author.id, username: message.author.username },
      { shop }
    )

    if (!profile) {
      return message.channel.send('Failed to update profile').then(del9)
    }

    const embed = new ProfileEmbed(profile, message.author)

    await message.channel
      .send({
        content: 'Your shop has been set',
        embeds: [embed]
      })
      .then(del9)
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/staff/addBadge.ts
/* eslint-disable @typescript-eslint/ban-ts-comment */

export class AddBadgeCmd extends Command {
  constructor () {
    super({
      name: 'addbadge',
      description: 'Add a badge to a user',
      category: 'Staff',
      validation: [ShinexRoles.ShinexAdminValidation],
      args: true,
      usage: '<user> <badge>'
    })
  }

  async run ({ message, args }: CommandRun) {
    const user = await UserFromMessage(message, args)

    if (!user) return message.reply('You must mention a user to add badge.')
    const badge = args.slice(1).join(' ').toUpperCase()
    if (!badge) {
      return message.reply('You must provide a badge to add to the user.')
    }

    if (!Badges.includes(badge as BadgeType)) {
      return message.reply(
        'Invalid Badge\n' + Object.keys(Badges).join(', ') + '.'
      )
    }

    const embed = new BotEmbed()
    embed.setTitle('Staff Tools')
    embed.setDescription(
      `user: \`${user.username}\` is added with badge \`${badge}\``
    )
    embed.setColor(Colors.Red)
    embed.setFooter({
      text: 'Badge added by ' + message.author.username + ' | Shinex'
    })

    const profile =
      vouchClient.profiles.cache.get(user.id) ||
      (await vouchClient.profiles.fetch({
        id: user.id,
        username: user.username
      }))
    if (!profile) {
      return message.channel.send('Failed to update profile')
    }

    const badges = profile.badges
    if (badges.includes(badge)) {
      return message.reply('User already has this badge.')
    }

    await profile.addBadge(badge)

    await message.channel.send({
      embeds: [embed]
    })
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/staff/block.ts

export class BlockProfileCmd extends Command {
  constructor () {
    super({
      name: 'block',
      description: 'Block a user from using the bot',
      category: 'Staff',
      args: true,
      usage: '<user> <reason>',
      validation: [ShinexRoles.ShinexAdminValidation]
    })
  }

  async run ({ message }: CommandRun) {
    message.reply('This command is not implemented yet')
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/staff/details.ts

export class VouchDetailsCmd extends Command {
  constructor () {
    super({
      name: 'details',
      description: 'Get details about a vouch',
      category: 'staff',
      args: true,
      aliases: ['detail'],
      validation: [ShinexRoles.ShinexSeniorModValidation]
    })
  }

  async run ({ message, args }: CommandRun) {
    const { ids } = ExtractIdsAndReason(args.join(' '))
    const vouches = (
      await vouchClient.vouches.fetchAll({
        vouchId: ids.map(i => i.trim()).join(',')
      })
    ).filter(v => v.isPending)

    for (const vouch of vouches) {
      const embed = new VouchEmbed(vouch)
      embed.setActivities()

      if (!vouch.isRelevantTo && !isAnyStaff(message.author.id)) {
        embed
          .setDescription(
            'This vouch is not relevant to you, so you cannot see it.'
          )
          .setFields([])
      }

      await message.channel
        .send({
          embeds: [embed]
        })
        .then(() => {
          if (
            !isAnyStaff(message.author.id) &&
            !message.content.includes('get')
          ) {
            del30(message)
          }
        })
    }

    await message.delete()
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/staff/dwc.ts

export class DwcCommand extends Command {
  constructor () {
    super({
      name: 'dwc',
      description: 'Mark DWC a user',
      category: 'Staff',
      args: true,
      usage: '<user>',
      validation: [ShinexRoles.ShinexAdminValidation]
    })
  }

  async run ({ message, args }: CommandRun) {
    const user = await UserFromMessage(message, args)
    if (!user) return message.reply('You must mention a user to DWC.')
    const reason = args.slice(1).join(' ')
    if (!reason) {
      return message.reply('You must provide a reason to DWC the user.')
    }
    const embed = new BotEmbed()
    embed.setTitle('Staff Tools')
    embed.setDescription(
      `user: \`${user.username}\` is marked as \`DWC\` for \`${reason}\``
    )
    embed.setColor(Colors.Red)
    embed.setFooter({
      text: 'DWC by ' + message.author.username + ' | Shinex'
    })

    await vouchClient.profiles.update(
      {
        id: user.id,
        username: user.username
      },
      {
        profileStatus: 'DEAL_WITH_CAUTION',
        warning: {
          reason,
          by: message.author.id,
          byUser: message.author.username,
          at: new Date()
        }
      }
    )

    await message.channel.send({
      embeds: [embed]
    })
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/staff/mark.ts

export class MarkCmd extends Command {
  constructor () {
    super({
      name: 'mark',
      description: 'Mark a user',
      category: 'Staff',
      args: true,
      usage: '<user> <reason>',
      validation: [ShinexRoles.ShinexAdminValidation]
    })
  }

  async run ({ message, args }: CommandRun) {
    const user = await UserFromMessage(message, args)
    if (!user) return message.reply('You must mention a user to mark.')
    const reason = args.slice(1).join(' ')
    if (!reason) {
      return message.reply('You must provide a reason to mark the user.')
    }
    const embed = new BotEmbed()
    embed.setTitle('Staff Tools')
    embed.setDescription(
      `user: \`${user.username}\` is marked as \`SCAMMER\` for \`${reason}\``
    )
    embed.setColor(Colors.Red)
    embed.setFooter({
      text: 'Marked by ' + message.author.username + ' | Shinex'
    })

    await vouchClient.profiles.update(
      {
        id: user.id,
        username: user.username
      },
      {
        profileStatus: 'SCAMMER',
        mark: {
          for: reason,
          by: message.author.id,
          byUser: message.author.username,
          at: new Date()
        }
      }
    )

    await message.channel.send({
      embeds: [embed]
    })
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/staff/pendings.ts

export class StaffVouchPending extends Command {
  constructor () {
    super({
      name: 'pending',
      description: 'View all pending vouches',
      category: 'Staff',
      usage: '<user> <type?>',
      aliases: ['pendings', 'pendingvouches', 'pendingvouch'],
      validation: [ShinexRoles.ShinexStaffValidation]
    })
  }

  async run ({ message, args, client }: CommandRun) {
    const replyEmbed = new BotEmbed({
      title: 'Pending Vouches',
      description: 'Loading pending vouches...'
    })
    const reply = await message.channel.send({ embeds: [replyEmbed] })

    const user = await UserFromMessage(message, args, {
      authorFromMessageAsReply: true
    })

    const type = args[1]

    if (
      type &&
      VouchStatusShortMap[
        type.toUpperCase() as typeof VouchStatusSchema._type
      ] === undefined
    ) {
      return reply.edit({
        embeds: [
          replyEmbed
            .setDescription(
              `Invalid type \`${type}\`\nValid types: \`${Object.keys(
                VouchStatusShortMap
              ).join('`, `')}\``
            )
            .setColor(client.config.themeColors.ERROR)
        ]
      })
    }

    const vouches = await vouchClient.vouches.fetchAll({ profileId: user?.id })

    const pendingVouches = vouches
      .filter(vouch => vouch.vouchStatus.toUpperCase() === 'UNCHECKED')
      .sort((a, b) => Number(a.id) - Number(b.id))

    if (!pendingVouches.length) {
      return reply.edit({
        embeds: [
          replyEmbed
            .setDescription(
              'No pending vouches' +
                (type ? ` of type \`${type}\`` : '') +
                ' found'
            )
            .setColor(client.config.themeColors.SECONDARY)
        ]
      })
    }

    reply
      .edit({
        embeds: [
          replyEmbed
            .setDescription(
              pendingVouches
                .map(vouch => {
                  if (type) {
                    return `${vouch.id}`
                  } else {
                    return `${vouch.id} - ${
                      VouchStatusMap[
                        vouch.vouchStatus.toUpperCase() as typeof VouchStatusSchema._type
                      ]
                    }`
                  }
                })
                .join('\n')
            )
            .setColor(client.config.themeColors.SUCCESS)
            .setAuthor({
              name: user?.username || message.author.displayName,
              iconURL:
                user?.displayAvatarURL({ forceStatic: false }) ||
                message.author.displayAvatarURL({ forceStatic: false })
            })
            .setTitle(
              'Pending ' + (type || 'Vouches') + ' | ' + pendingVouches.length
            )
        ]
      })
      .then(() => message.delete())
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/staff/unmark.ts

export class UnMarkCmd extends Command {
  constructor () {
    super({
      name: 'unmark',
      description: 'Unmark a user',
      category: 'Staff',
      args: true,
      usage: '<user>',
      validation: [ShinexRoles.ShinexAdminValidation]
    })
  }

  async run ({ message, args }: CommandRun) {
    const user = await UserFromMessage(message, args)
    if (!user) return message.reply('You must mention a user to unmark.')

    const embed = new BotEmbed()
    embed.setTitle('Staff Tools')
    embed.setDescription(
      `user: \`${user.username}\` is unmarked as \`SCAMMER\``
    )
    embed.setColor(Colors.Red)
    embed.setFooter({
      text: 'Unmarked by ' + message.author.username + ' | Shinex'
    })

    await vouchClient.profiles.update(
      {
        id: user.id,
        username: user.username
      },
      {
        profileStatus: 'GOOD',
        mark: {},
        warning: {}
      }
    )

    await message.channel.send({
      embeds: [embed]
    })
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/vouch/approve.ts

export class ApproveVouchCmd extends Command {
  constructor () {
    super({
      name: 'approve',
      description: 'Approve a vouch',
      category: 'Vouch',
      aliases: ['a', 'accept'],
      validation: [ShinexRoles.ShinexStaffValidation],
      args: true,
      usage: '<vouchId>'
    })
  }

  async run ({ message, args }: CommandRun) {
    const { ids } = ExtractIdsAndReason(args.join(' '))
    const vouches = await vouchClient.vouches.fetchAll({
      vouchId: ids.map(i => i.trim()).join(',')
    })

    let description = 'Approving vouches\n'
    const embed = new BotEmbed()
      .setTitle('Staff Tools')
      .setDescription(description)

    const replyMessage = await message.reply({
      embeds: [embed]
    })

    if (!vouches.length) {
      return replyMessage.edit({
        embeds: [
          embed
            .setDescription('No vouches found')
            .setColor(client.config.themeColors.ERROR)
        ]
      })
    }

    let errorCount = 0

    for (const vouch of vouches) {
      if (vouch.isApproved) {
        description += `Vouch with id \`${vouch.id}\` is already approved\n`
        await replyMessage.edit({
          embeds: [embed.setDescription(description)]
        })
        continue
      }

      // if (
      //   (vouch.receiverId === message.author.id ||
      //     vouch.voucherId === message.author.id) &&
      //   !process.env.DEV
      // ) {
      //   description += `- Vouch with id \`${vouch.id}\` cannot be approved by the voucher or receiver\n`
      //   await replyMessage.edit({
      //     embeds: [embed.setDescription(description)]
      //   })
      //   continue
      // }

      let error = false

      await OnApprove(vouch, message.author, message)
        .catch(async () => {
          description += `- Failed approving vouch with id \`${vouch.id}\`\n`
          await replyMessage.edit({
            embeds: [embed.setDescription(description)]
          })
          error = true
          errorCount++
        })
        .then(async () => {
          if (error) return
          description += `- Vouch with id \`${vouch.id}\` has been approved\n`
          await replyMessage.edit({
            embeds: [embed.setDescription(description)]
          })
        })
    }

    const successCount = vouches.length - errorCount

    description +=
      '\nApproved all vouches\nTotal vouches to approved: ' + successCount
    await replyMessage.edit({
      embeds: [
        embed
          .setDescription(description)
          .setColor(
            successCount < errorCount
              ? client.config.themeColors.ERROR
              : client.config.themeColors.SUCCESS
          )
      ]
    })
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/vouch/delete.ts

export class DeleteVouchCmd extends Command {
  constructor () {
    super({
      name: 'delete',
      description: 'Delete a vouch',
      category: 'Vouch',
      args: true,
      usage: '<vouchId>',

      validation: [ShinexRoles.ShinexSeniorModValidation]
    })
  }

  async run ({ message, args }: CommandRun) {
    const { ids } = ExtractIdsAndReason(args.join(' '))
    const vouches = await vouchClient.vouches.fetchAll({
      vouchId: ids.map(i => i.trim()).join(',')
    })

    let description = 'Deleting vouches\n'
    const embed = new BotEmbed()
      .setTitle('Staff Tools')
      .setDescription(description)

    const replyMessage = await message.reply({
      embeds: [embed]
    })

    let errorCount = 0

    for (const vouch of vouches) {
      if (vouch.isDeleted) {
        description += `Vouch with id \`${vouch.id}\` is already deleted\n`
        await replyMessage.edit({
          embeds: [embed.setDescription(description)]
        })
        continue
      }

      let error = false

      try {
        await vouchClient.vouches.delete(vouch.id, {
          staffId: message.author.id,
          staffName: message.author.username,
          reason: 'Deleted by staff'
        })
      } catch (err) {
        error = true
        errorCount++
        description += `Failed to delete vouch with id \`${vouch.id}\`\n`
        await replyMessage.edit({
          embeds: [embed.setDescription(description)]
        })
      } finally {
        if (!error) {
          description += `Deleted vouch with id \`${vouch.id}\`\n`
          await replyMessage.edit({
            embeds: [embed.setDescription(description)]
          })
        }
      }
    }

    description +=
      '\nDeleted all vouches\nTotal vouches to deleted: ' +
      (vouches.length - errorCount)
    await replyMessage.edit({
      embeds: [
        embed
          .setDescription(description)
          .setColor(client.config.themeColors.SUCCESS)
      ]
    })
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/vouch/deny.ts

export class DenyVouchCmd extends Command {
  constructor () {
    super({
      name: 'deny',
      description: 'Deny a vouch',
      category: 'Vouch',
      aliases: ['d'],

      validation: [ShinexRoles.ShinexStaffValidation],
      args: true,
      usage: '<vouchId> <reason>'
    })
  }

  async run ({ message, args }: CommandRun) {
    const { ids, reason } = ExtractIdsAndReason(args.join(' '))
    const vouches = await vouchClient.vouches.fetchAll({
      vouchId: ids.map(i => i.trim()).join(',')
    })

    let description = 'Denying vouches\n**Reason**: ' + reason + '\n\n'
    const embed = new BotEmbed()
      .setTitle('Staff Tools')
      .setDescription(description)

    const replyMessage = await message.channel.send({
      embeds: [embed]
    })

    let errorCount = 0

    for (const vouch of vouches) {
      if (vouch.isApproved) {
        description += `Vouch with id \`${vouch.id}\` is already denied\n`
        await replyMessage.edit({
          embeds: [embed.setDescription(description)]
        })
        continue
      }

      // if (
      //   (vouch.receiverId === message.author.id ||
      //     vouch.voucherId === message.author.id) &&
      //   !process.env.DEV
      // ) {
      //   description += `- Vouch with id \`${vouch.id}\` cannot be denied by the voucher or receiver\n`
      //   await replyMessage.edit({
      //     embeds: [embed.setDescription(description)]
      //   })
      //   continue
      // }

      let error = false

      await OnDeny(vouch, message.author, message, reason)
        .catch(async () => {
          description += `- Error denying vouch with id \`${vouch.id}\`\n`
          await replyMessage.edit({
            embeds: [embed.setDescription(description)]
          })
          error = true
          errorCount++
        })
        .then(async () => {
          if (error) return
          description += `- Vouch with id \`${vouch.id}\` has been denied\n`
          await replyMessage.edit({
            embeds: [embed.setDescription(description)]
          })
        })
    }

    description +=
      '\nDenied all vouches\nTotal vouches to deny: ' +
      (vouches.length - errorCount)
    await replyMessage.edit({
      embeds: [
        embed
          .setDescription(description)
          .setColor(client.config.themeColors.WARNING)
      ]
    })
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/vouch/denyReason.ts

export class DenyReasonCmd extends Command {
  constructor () {
    super({
      name: 'denyreason',
      description: 'See the deny reasons for a vouch',
      category: 'Staff',

      validation: [ShinexRoles.ShinexStaffValidation]
    })
  }

  async run ({ message }: CommandRun) {
    const embed = new BotEmbed()
    embed.setTitle('Vouch Deny Reason help')

    embed
      .addFields(
        {
          name: 'Usage',
          value: '`!deny <vouchId> <reason>`'
        },
        {
          name: 'Shortcuts',
          value: Object.keys(DenyReasons)
            .map(key => `\`${key}\``)
            .join(', ')
        },
        {
          name: 'Custom Reasons',
          value:
            'You can also use custom reasons by typing the reason after the vouch id.'
        }
      )
      .setColor(0x1b03a3)

    await message.channel.send({
      embeds: [embed]
    })
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/vouch/status.ts

export class StatusCommand extends Command {
  constructor () {
    super({
      name: 'status',
      description: 'Shows the status of a vouch',
      category: 'Vouch',
      aliases: ['get'],
      args: true,
      usage: '<vouchId>'
    })
  }

  async run ({ message, args }: CommandRun) {
    const { ids } = ExtractIdsAndReason(args.join(' '))
    const vouches = (
      await vouchClient.vouches.fetchAll({
        vouchId: ids.map(i => i.trim()).join(',')
      })
    ).filter(v => v.isPending)

    for (const vouch of vouches) {
      const embed = new VouchEmbed(vouch)

      if (!vouch.isRelevantTo && !isAnyStaff(message.author.id)) {
        embed
          .setDescription(
            'This vouch is not relevant to you, so you cannot see it.'
          )
          .setFields([])
      }

      await message.channel
        .send({
          embeds: [embed]
        })
        .then(() => {
          if (
            !isAnyStaff(message.author.id) &&
            !message.content.includes('get')
          ) {
            del30(message)
          }
        })
    }

    await message.delete()
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/vouch/vouch.ts

export class VouchCmd extends Command {
  constructor () {
    super({
      name: 'vouch',
      category: 'Vouch',
      description: 'Vouch a user',
      aliases: ['rep'],
      args: true,
      usage: '<user> <comment>'
    })
  }

  async run ({ message, client, args }: CommandRun) {
    if (!message.guild) {
      return message.reply('This command can only be used in a server')
    }

    let user: GuildMember | undefined

    if (args[0].startsWith('<@') && args[0].endsWith('>')) {
      user = await message.guild?.members.fetch(
        args[0].replace('<@', '').replace('>', '')
      )
    } else if (/\d+/.test(args[0])) {
      user = await message.guild?.members.fetch(args[0])
    } else if (args[0]) {
      const users = await message.guild?.members.search({
        query: args[0]
      })
      user = users?.first()
    }

    const comment = args.slice(1).join(' ')
    if (!user) {
      return message
        .reply({
          embeds: [
            new BotEmbed({
              title: 'Vouch Failed',
              description: 'Please mention a valid user to vouch',
              color: client.config.themeColors.ERROR
            })
          ]
        })
        .then(del9)
    }

    if (user.user.bot) {
      return message
        .reply({
          embeds: [
            new BotEmbed({
              title: 'Vouch Failed',
              description: 'You cannot vouch a bot',
              color: client.config.themeColors.ERROR
            })
          ]
        })
        .then(del9)
    }

    if (!comment) {
      return message
        .reply({
          embeds: [
            new BotEmbed({
              title: 'Vouch Failed',
              description: 'Please provide a comment to vouch',
              color: client.config.themeColors.ERROR
            })
          ]
        })
        .then(del9)
    }

    if (comment.length > 240) {
      return message
        .reply({
          embeds: [
            new BotEmbed({
              title: 'Vouch Failed',
              description: 'Comment is too long.',
              color: client.config.themeColors.ERROR
            })
          ]
        })
        .then(del9)
    }

    if (!/\d/.test(comment)) {
      return message
        .reply({
          embeds: [
            new BotEmbed({
              title: 'Vouch Failed',
              description:
                'Please mention a value of the trade in your comment.',
              color: client.config.themeColors.ERROR
            })
          ]
        })
        .then(del9)
    }

    if (user.id === message.author.id) {
      return message
        .reply({
          embeds: [
            new BotEmbed({
              title: 'Vouch Failed',
              description: 'You cannot vouch yourself',
              color: client.config.themeColors.ERROR
            })
          ]
        })
        .then(del9)
    }

    await vouchClient.vouches
      .post({
        comment,
        receiverId: user.id,
        receiverName: user.user.username,
        voucherId: message.author.id,
        voucherName: message.author.username,
        serverId: message.guild?.id,
        serverName: message.guild?.name
      })
      .then(async vouch => {
        await message
          .reply({
            embeds: [
              new BotEmbed({
                title: 'Vouch Successful',
                description: `You have vouched <@${user?.id}> with the comment \`${comment}\`\n\nThank you for vouching!`,
                color: 0x1b03a3
              })
            ]
          })
          .then(msg => {
            setTimeout(() => {
              msg.delete()
            }, 9000)
          })

        if (!vouch) {
          message.react('❌')
          return
        }

        await user?.send({
          embeds: [
            new VouchNotification({
              description: `You have received a vouch \`${vouch?.id}\` by \`${vouch?.voucherName}\`.`
            })
          ]
        })
      })
      .catch(e => {
        message.reply({
          embeds: [
            new BotEmbed({
              title: 'Vouch Failed',
              description: '' + e,
              color: client.config.themeColors.ERROR
            })
          ]
        })
      })
  }
}

// Content From D:\DISCORD TS\shinex\src\main\commands/vouch/vouchHelp.ts

export class VouchHelp extends Command {
  constructor () {
    super({
      name: 'vouchhelp',
      description: 'Help users with vouching',
      category: 'Vouch',
      aliases: ['vouchh', 'vh'],
      args: true,
      usage: '<comment>'
    })
  }

  async run ({ message, args, client }: CommandRun) {
    const user = message.author

    const comment = args.join(' ')

    if (!comment) {
      return message.reply('Use Correctly `vh <user> <comment>`')
    }

    const embed = new BotEmbed({
      title: `Please vouch ${user.username}`,
      description: `Please vouch \`${user.username}\` with the comment \`${comment}\``,
      color: 0x1b03a3,
      fields: [
        {
          name: 'Command',
          value: client.config.prefix + `vouch ${user.id} ${comment}`
        }
      ]
    })

    return message.channel.send({
      embeds: [embed]
    })
  }
}
